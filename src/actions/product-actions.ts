// src/actions/product-actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import { z } from 'zod';
import { prisma } from '@/lib/prisma';
import type { Product } from '@/types';

// Schema for adding a new product (id is generated by DB)
const AddProductSchema = z.object({
  name: z.string().min(2, { message: 'Product name must be at least 2 characters.' }),
  category: z.string().min(1, { message: 'Category is required.' }),
  price: z.coerce.number().positive({ message: 'Price must be a positive number.' }),
  description: z.string().optional(),
});

// Schema for updating an existing product (id is required)
const UpdateProductSchema = AddProductSchema.extend({
  id: z.string().cuid({ message: 'Invalid product ID.' }),
});


export async function getProducts(): Promise<Product[]> {
  try {
    const products = await prisma.product.findMany({
      orderBy: {
        createdAt: 'desc', // Or 'name', 'category', etc.
      },
    });
    // Ensure price is returned as a number
    return products.map(p => ({ ...p, price: Number(p.price) }));
  } catch (error) {
    console.error('Failed to fetch products:', error);
    // Consider returning an empty array or throwing a more specific error
    return [];
  }
}

export async function addProduct(data: z.infer<typeof AddProductSchema>): Promise<{ success: boolean; error?: string }> {
   const validation = AddProductSchema.safeParse(data);
   if (!validation.success) {
       return { success: false, error: validation.error.flatten().fieldErrors.toString() }; // Or format error message better
   }

  try {
    await prisma.product.create({
      data: validation.data,
    });
    revalidatePath('/admin'); // Revalidate the admin page
    revalidatePath('/'); // Also revalidate the home page if needed
    return { success: true };
  } catch (error) {
    console.error('Failed to add product:', error);
    return { success: false, error: 'Database error: Could not add product.' };
  }
}

export async function updateProduct(data: z.infer<typeof UpdateProductSchema>): Promise<{ success: boolean; error?: string }> {
   const validation = UpdateProductSchema.safeParse(data);
   if (!validation.success) {
     return { success: false, error: validation.error.flatten().fieldErrors.toString() };
   }

  try {
    await prisma.product.update({
      where: { id: validation.data.id },
      data: {
         name: validation.data.name,
         category: validation.data.category,
         price: validation.data.price,
         description: validation.data.description,
       },
    });
    revalidatePath('/admin'); // Revalidate the admin page
    revalidatePath('/'); // Also revalidate the home page if needed
    return { success: true };
  } catch (error) {
    console.error('Failed to update product:', error);
     return { success: false, error: 'Database error: Could not update product.' };
  }
}

export async function deleteProduct(productId: string): Promise<{ success: boolean; error?: string }> {
    if (!productId || typeof productId !== 'string') {
      return { success: false, error: 'Invalid product ID provided.' };
    }
  try {
    await prisma.product.delete({
      where: { id: productId },
    });
    revalidatePath('/admin'); // Revalidate the admin page
    revalidatePath('/'); // Also revalidate the home page if needed
    return { success: true };
  } catch (error) {
    console.error('Failed to delete product:', error);
    return { success: false, error: 'Database error: Could not delete product.' };
  }
}
